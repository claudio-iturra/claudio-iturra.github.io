<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Series Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }
        
        .input-section {
            background: #f8fafc;
            border-radius: 15px;
            padding: 25px;
            border: 2px solid #e2e8f0;
        }
        
        .section-title {
            font-size: 1.4rem;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 8px;
        }
        
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }
        
        .form-group textarea {
            resize: vertical;
            min-height: 120px;
            font-family: 'Courier New', monospace;
        }
        
        .datetime-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .resolution-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .results-section {
            background: #f8fafc;
            border-radius: 15px;
            padding: 25px;
            border: 2px solid #e2e8f0;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 20px;
            background: white;
            border-radius: 10px;
            padding: 15px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #4facfe;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .stat-card h4 {
            color: #4a5568;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }
        
        .stat-card .value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #2d3748;
        }
        
        .interpolation-methods {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .method-btn {
            padding: 10px 15px;
            border: 2px solid #e2e8f0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 14px;
        }
        
        .method-btn.active {
            background: #4facfe;
            color: white;
            border-color: #4facfe;
        }
        
        .method-btn:hover {
            border-color: #4facfe;
        }
        
        .alert {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid;
        }
        
        .alert.error {
            background: #fed7d7;
            border-color: #e53e3e;
            color: #742a2a;
        }
        
        .alert.success {
            background: #c6f6d5;
            border-color: #38a169;
            color: #22543d;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .datetime-inputs, .resolution-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ“Š Time Series Analyzer</h1>
            <p>Advanced interpolation and resampling for temporal data analysis by Claudio Iturra</p>
        </div>
        
        <div class="main-content">
            <div class="input-section">
                <h2 class="section-title">
                    ðŸ“¥ Data Input & Configuration
                </h2>
                
                <div class="form-group">
                    <label for="timeSeriesData">Time Series Data (one value per line):</label>
                    <textarea id="timeSeriesData" placeholder="Enter your time series values, one per line:&#10;23.5&#10;24.1&#10;NaN&#10;25.3&#10;24.8&#10;..."></textarea>
                </div>
                
                <div class="form-group">
                    <label>First Timestamp:</label>
                    <div class="datetime-inputs">
                        <input type="date" id="startDate" value="2024-01-01">
                        <input type="time" id="startTime" value="00:00">
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Original Temporal Resolution:</label>
                    <div class="resolution-grid">
                        <input type="number" id="originalInterval" value="1" min="1">
                        <select id="originalUnit">
                            <option value="minutes">Minutes</option>
                            <option value="hours" selected>Hours</option>
                            <option value="days">Days</option>
                            <option value="weeks">Weeks</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Target Temporal Resolution:</label>
                    <div class="resolution-grid">
                        <input type="number" id="targetInterval" value="1" min="1">
                        <select id="targetUnit">
                            <option value="minutes">Minutes</option>
                            <option value="hours">Hours</option>
                            <option value="days" selected>Days</option>
                            <option value="weeks">Weeks</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Interpolation Method:</label>
                    <div class="interpolation-methods">
                        <div class="method-btn active" data-method="linear">Linear</div>
                        <div class="method-btn" data-method="spline">Spline</div>
                        <div class="method-btn" data-method="polynomial">Polynomial</div>
                        <div class="method-btn" data-method="nearest">Nearest</div>
                    </div>
                </div>
                
                <button class="btn" onclick="processTimeSeries()">
                    ðŸ”„ Process Time Series
                </button>
                
                <button class="btn" id="downloadBtn" onclick="downloadResults()" style="margin-top: 15px; background: linear-gradient(135deg, #48bb78 0%, #38a169 100%); display: none;">
                    ðŸ“¥ Download Interpolated Data
                </button>
                
                <button class="btn" onclick="generateSyntheticData()" style="margin-top: 15px; background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);">
                    ðŸŽ² Generate Synthetic Data
                </button>
            </div>
            
            <div class="results-section">
                <h2 class="section-title">
                    ðŸ“ˆ Analysis Results
                </h2>
                
                <div id="alertContainer"></div>
                
                <div class="chart-container">
                    <canvas id="timeSeriesChart"></canvas>
                </div>
                
                <div class="stats-grid" id="statsContainer">
                    <!-- Stats will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        let chart = null;
        let selectedMethod = 'linear';
        let processedResults = null;
        
        // Method selection
        document.querySelectorAll('.method-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.method-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                selectedMethod = this.dataset.method;
            });
        });
        
        function showAlert(message, type = 'error') {
            const container = document.getElementById('alertContainer');
            container.innerHTML = `<div class="alert ${type}">${message}</div>`;
            setTimeout(() => container.innerHTML = '', 5000);
        }
        
        function parseTimeSeries(data) {
            const lines = data.trim().split('\n');
            const values = [];
            
            for (let line of lines) {
                const trimmed = line.trim();
                if (trimmed === '' || trimmed.toLowerCase() === 'nan' || trimmed === 'null') {
                    values.push(NaN);
                } else {
                    const num = parseFloat(trimmed);
                    values.push(isNaN(num) ? NaN : num);
                }
            }
            
            return values;
        }
        
        function getMillisecondsFromUnit(value, unit) {
            const multipliers = {
                minutes: 60 * 1000,
                hours: 60 * 60 * 1000,
                days: 24 * 60 * 60 * 1000,
                weeks: 7 * 24 * 60 * 60 * 1000
            };
            return value * multipliers[unit];
        }
        
        function generateTimestamps(startDate, startTime, count, interval, unit) {
            const start = new Date(`${startDate}T${startTime}`);
            const intervalMs = getMillisecondsFromUnit(interval, unit);
            const timestamps = [];
            
            for (let i = 0; i < count; i++) {
                timestamps.push(new Date(start.getTime() + i * intervalMs));
            }
            
            return timestamps;
        }
        
        function interpolateLinear(x1, y1, x2, y2, x) {
            return y1 + (y2 - y1) * (x - x1) / (x2 - x1);
        }
        
        function interpolateSpline(points, x) {
            // Simple cubic spline approximation
            if (points.length < 2) return points[0]?.y || 0;
            
            // Find surrounding points
            let i = 0;
            while (i < points.length - 1 && points[i + 1].x < x) i++;
            
            if (i === 0) return points[0].y;
            if (i >= points.length - 1) return points[points.length - 1].y;
            
            const p0 = points[Math.max(0, i - 1)];
            const p1 = points[i];
            const p2 = points[i + 1];
            const p3 = points[Math.min(points.length - 1, i + 2)];
            
            const t = (x - p1.x) / (p2.x - p1.x);
            const t2 = t * t;
            const t3 = t2 * t;
            
            return 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + 
                         (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + 
                         (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3);
        }
        
        function interpolatePolynomial(points, x) {
            // Lagrange polynomial interpolation
            if (points.length === 0) return 0;
            if (points.length === 1) return points[0].y;
            
            let result = 0;
            for (let i = 0; i < points.length; i++) {
                let term = points[i].y;
                for (let j = 0; j < points.length; j++) {
                    if (i !== j) {
                        term *= (x - points[j].x) / (points[i].x - points[j].x);
                    }
                }
                result += term;
            }
            return result;
        }
        
        function fillNaNValues(values, timestamps, method) {
            const result = [...values];
            const validPoints = [];
            
            // Collect valid points
            for (let i = 0; i < values.length; i++) {
                if (!isNaN(values[i])) {
                    validPoints.push({ x: timestamps[i].getTime(), y: values[i] });
                }
            }
            
            if (validPoints.length === 0) return result;
            
            // Fill NaN values
            for (let i = 0; i < result.length; i++) {
                if (isNaN(result[i])) {
                    const x = timestamps[i].getTime();
                    
                    switch (method) {
                        case 'linear':
                            // Find surrounding valid points
                            let before = null, after = null;
                            for (let j = 0; j < validPoints.length; j++) {
                                if (validPoints[j].x <= x) before = validPoints[j];
                                if (validPoints[j].x >= x && !after) after = validPoints[j];
                            }
                            
                            if (before && after && before.x !== after.x) {
                                result[i] = interpolateLinear(before.x, before.y, after.x, after.y, x);
                            } else if (before) {
                                result[i] = before.y;
                            } else if (after) {
                                result[i] = after.y;
                            }
                            break;
                            
                        case 'spline':
                            result[i] = interpolateSpline(validPoints, x);
                            break;
                            
                        case 'polynomial':
                            // Use nearby points for polynomial interpolation
                            const nearbyPoints = validPoints.slice(0, Math.min(4, validPoints.length));
                            result[i] = interpolatePolynomial(nearbyPoints, x);
                            break;
                            
                        case 'nearest':
                            let nearest = validPoints[0];
                            let minDist = Math.abs(x - nearest.x);
                            for (let point of validPoints) {
                                const dist = Math.abs(x - point.x);
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearest = point;
                                }
                            }
                            result[i] = nearest.y;
                            break;
                    }
                }
            }
            
            return result;
        }
        
        function resampleTimeSeries(values, originalTimestamps, targetInterval, targetUnit) {
            const startTime = originalTimestamps[0].getTime();
            const endTime = originalTimestamps[originalTimestamps.length - 1].getTime();
            const targetIntervalMs = getMillisecondsFromUnit(targetInterval, targetUnit);
            
            const newTimestamps = [];
            const newValues = [];
            
            let currentTime = startTime;
            while (currentTime <= endTime) {
                newTimestamps.push(new Date(currentTime));
                
                // Find the closest original values for interpolation
                let value = 0;
                let beforeIdx = -1, afterIdx = -1;
                
                for (let i = 0; i < originalTimestamps.length; i++) {
                    if (originalTimestamps[i].getTime() <= currentTime) {
                        beforeIdx = i;
                    }
                    if (originalTimestamps[i].getTime() >= currentTime && afterIdx === -1) {
                        afterIdx = i;
                        break;
                    }
                }
                
                if (beforeIdx !== -1 && afterIdx !== -1 && beforeIdx !== afterIdx) {
                    const x1 = originalTimestamps[beforeIdx].getTime();
                    const y1 = values[beforeIdx];
                    const x2 = originalTimestamps[afterIdx].getTime();
                    const y2 = values[afterIdx];
                    
                    if (!isNaN(y1) && !isNaN(y2)) {
                        value = interpolateLinear(x1, y1, x2, y2, currentTime);
                    } else if (!isNaN(y1)) {
                        value = y1;
                    } else if (!isNaN(y2)) {
                        value = y2;
                    } else {
                        value = NaN;
                    }
                } else if (beforeIdx !== -1) {
                    value = values[beforeIdx];
                } else if (afterIdx !== -1) {
                    value = values[afterIdx];
                } else {
                    value = NaN;
                }
                
                newValues.push(value);
                currentTime += targetIntervalMs;
            }
            
            return { timestamps: newTimestamps, values: newValues };
        }
        
        function calculateStats(original, processed) {
            const validOriginal = original.filter(v => !isNaN(v));
            const validProcessed = processed.filter(v => !isNaN(v));
            
            const nanCount = original.filter(v => isNaN(v)).length;
            const nanPercentage = (nanCount / original.length * 100).toFixed(1);
            
            const originalMean = validOriginal.reduce((a, b) => a + b, 0) / validOriginal.length;
            const processedMean = validProcessed.reduce((a, b) => a + b, 0) / validProcessed.length;
            
            return {
                originalCount: original.length,
                processedCount: processed.length,
                nanCount,
                nanPercentage,
                originalMean: originalMean.toFixed(2),
                processedMean: processedMean.toFixed(2)
            };
        }
        
        function updateChart(originalData, processedData, originalTimestamps, processedTimestamps) {
            const ctx = document.getElementById('timeSeriesChart').getContext('2d');
            
            if (chart) {
                chart.destroy();
            }
            
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Original Data',
                        data: originalTimestamps.map((t, i) => ({
                            x: t,
                            y: originalData[i]
                        })),
                        borderColor: '#e53e3e',
                        backgroundColor: 'rgba(229, 62, 62, 0.1)',
                        borderWidth: 2,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        spanGaps: false
                    }, {
                        label: 'Processed Data',
                        data: processedTimestamps.map((t, i) => ({
                            x: t,
                            y: processedData[i]
                        })),
                        borderColor: '#4facfe',
                        backgroundColor: 'rgba(79, 172, 254, 0.1)',
                        borderWidth: 2,
                        pointRadius: 2,
                        pointHoverRadius: 4,
                        spanGaps: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Time Series Analysis Results'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                displayFormats: {
                                    hour: 'MMM dd HH:mm',
                                    day: 'MMM dd',
                                    week: 'MMM dd'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Value'
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }
        
        function updateStats(stats) {
            const container = document.getElementById('statsContainer');
            container.innerHTML = `
                <div class="stat-card">
                    <h4>Original Points</h4>
                    <div class="value">${stats.originalCount}</div>
                </div>
                <div class="stat-card">
                    <h4>Processed Points</h4>
                    <div class="value">${stats.processedCount}</div>
                </div>
                <div class="stat-card">
                    <h4>NaN Values</h4>
                    <div class="value">${stats.nanCount} (${stats.nanPercentage}%)</div>
                </div>
                <div class="stat-card">
                    <h4>Original Mean</h4>
                    <div class="value">${stats.originalMean}</div>
                </div>
                <div class="stat-card">
                    <h4>Processed Mean</h4>
                    <div class="value">${stats.processedMean}</div>
                </div>
                <div class="stat-card">
                    <h4>Method Used</h4>
                    <div class="value">${selectedMethod.charAt(0).toUpperCase() + selectedMethod.slice(1)}</div>
                </div>
            `;
        }
        
        function processTimeSeries() {
            try {
                // Get input values
                const dataText = document.getElementById('timeSeriesData').value;
                const startDate = document.getElementById('startDate').value;
                const startTime = document.getElementById('startTime').value;
                const originalInterval = parseInt(document.getElementById('originalInterval').value);
                const originalUnit = document.getElementById('originalUnit').value;
                const targetInterval = parseInt(document.getElementById('targetInterval').value);
                const targetUnit = document.getElementById('targetUnit').value;
                
                if (!dataText.trim()) {
                    showAlert('Please enter time series data');
                    return;
                }
                
                // Parse data
                const originalValues = parseTimeSeries(dataText);
                const originalTimestamps = generateTimestamps(startDate, startTime, originalValues.length, originalInterval, originalUnit);
                
                // Fill NaN values
                const filledValues = fillNaNValues(originalValues, originalTimestamps, selectedMethod);
                
                // Resample if needed
                let processedValues, processedTimestamps;
                const originalIntervalMs = getMillisecondsFromUnit(originalInterval, originalUnit);
                const targetIntervalMs = getMillisecondsFromUnit(targetInterval, targetUnit);
                
                if (originalIntervalMs !== targetIntervalMs) {
                    const resampled = resampleTimeSeries(filledValues, originalTimestamps, targetInterval, targetUnit);
                    processedValues = resampled.values;
                    processedTimestamps = resampled.timestamps;
                } else {
                    processedValues = filledValues;
                    processedTimestamps = originalTimestamps;
                }
                
                // Calculate statistics
                const stats = calculateStats(originalValues, processedValues);
                
                // Store results for download
                processedResults = {
                    originalValues,
                    processedValues,
                    originalTimestamps,
                    processedTimestamps
                };
                
                // Update visualization
                updateChart(originalValues, processedValues, originalTimestamps, processedTimestamps);
                updateStats(stats);
                
                // Show download button
                document.getElementById('downloadBtn').style.display = 'block';
                
                showAlert('Time series processed successfully!', 'success');
                
            } catch (error) {
                showAlert(`Error processing time series: ${error.message}`);
                console.error(error);
            }
        }
        
        function downloadResults() {
            if (!processedResults) {
                showAlert('No processed data available for download');
                return;
            }
            
            let csvContent = "";
            
            // Create simple text file with only interpolated values, one per line
            for (let i = 0; i < processedResults.processedValues.length; i++) {
                const value = isNaN(processedResults.processedValues[i]) ? 'NaN' : processedResults.processedValues[i];
                csvContent += `${value}\n`;
            }
            
            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/plain;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `interpolated_data_${new Date().toISOString().split('T')[0]}.txt`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showAlert('Data downloaded successfully!', 'success');
        }
        
        function generateSyntheticData() {
            const points = 50;
            const syntheticData = [];
            
            // Generate synthetic time series with trend, seasonality, and noise
            for (let i = 0; i < points; i++) {
                let value;
                
                // Add some NaN values randomly (10% chance)
                if (Math.random() < 0.1) {
                    value = 'NaN';
                } else {
                    // Trend component
                    const trend = 20 + (i * 0.1);
                    
                    // Seasonal component (daily cycle)
                    const seasonal = 5 * Math.sin(2 * Math.PI * i / 24);
                    
                    // Random noise
                    const noise = (Math.random() - 0.5) * 4;
                    
                    // Occasional spikes
                    const spike = Math.random() < 0.05 ? (Math.random() - 0.5) * 10 : 0;
                    
                    value = (trend + seasonal + noise + spike).toFixed(2);
                }
                
                syntheticData.push(value);
            }
            
            document.getElementById('timeSeriesData').value = syntheticData.join('\n');
            showAlert('Synthetic time series generated! Contains trend, seasonality, noise, and missing values.', 'success');
        }

        function generateHourlyData() {
            const hoursIn30Days = 30 * 24; // 720 hours
            const hourlyData = [];
            
            for (let hour = 0; hour < hoursIn30Days; hour++) {
                let value;
                
                // Add some NaN values randomly (5% chance)
                if (Math.random() < 0.05) {
                    value = 'NaN';
                } else {
                    // Base temperature around 20Â°C
                    let temp = 20;
                    
                    // Daily temperature cycle (warmer during day, cooler at night)
                    const hourOfDay = hour % 24;
                    const dailyCycle = 8 * Math.sin(2 * Math.PI * (hourOfDay - 6) / 24);
                    
                    // Weekly pattern (slightly warmer on weekends)
                    const dayOfWeek = Math.floor(hour / 24) % 7;
                    const weeklyPattern = (dayOfWeek >= 5) ? 1.5 : 0;
                    
                    // Monthly trend (gradual warming over 30 days)
                    const monthlyTrend = (hour / hoursIn30Days) * 3;
                    
                    // Weather variations (larger changes every few days)
                    const weatherCycle = 4 * Math.sin(2 * Math.PI * hour / (72)); // 3-day cycle
                    
                    // Random noise
                    const noise = (Math.random() - 0.5) * 2;
                    
                    // Occasional weather events (storms, heat waves)
                    let weatherEvent = 0;
                    if (Math.random() < 0.02) { // 2% chance
                        weatherEvent = (Math.random() - 0.5) * 8;
                    }
                    
                    temp = temp + dailyCycle + weeklyPattern + monthlyTrend + weatherCycle + noise + weatherEvent;
                    value = temp.toFixed(1);
                }
                
                hourlyData.push(value);
            }
            
            return hourlyData.join('\n');
        }

        // Initialize with realistic 30-day hourly temperature data
        document.addEventListener('DOMContentLoaded', function() {
            const hourlyData = generateHourlyData();
            document.getElementById('timeSeriesData').value = hourlyData;
            
            // Set appropriate default settings for hourly data
            document.getElementById('originalInterval').value = '1';
            document.getElementById('originalUnit').value = 'hours';
            document.getElementById('targetInterval').value = '6';
            document.getElementById('targetUnit').value = 'hours';
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'972ac7a6322c88b2',t:'MTc1NTc4NjExOC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Time Series Analysis: Spectral & Wavelet</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/plotly.js-dist@2.26.0/plotly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 30%, #f093fb 70%, #ff9a9e 100%);
            color: white;
            padding: 40px;
            text-align: center;
            position: relative;
        }
        
        .header::before {
            content: '🌊';
            position: absolute;
            top: 30px;
            right: 40px;
            font-size: 3rem;
            animation: wave 3s ease-in-out infinite;
        }
        
        @keyframes wave {
            0%, 100% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(5deg) scale(1.1); }
            75% { transform: rotate(-5deg) scale(0.9); }
        }
        
        .header h1 {
            font-size: 3.5rem;
            margin-bottom: 15px;
            font-weight: 300;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            font-size: 1.4rem;
            opacity: 0.9;
            margin-bottom: 8px;
        }
        
        .header .subtitle {
            font-size: 1.1rem;
            opacity: 0.75;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 450px 1fr;
            gap: 0;
            min-height: 1200px;
        }
        
        .input-panel {
            background: #f8fafc;
            padding: 30px;
            border-right: 1px solid #e2e8f0;
            overflow-y: auto;
            max-height: 1200px;
        }
        
        .input-section {
            margin-bottom: 25px;
            padding: 25px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            border: 1px solid #e2e8f0;
        }
        
        .section-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #667eea;
            margin-bottom: 18px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .data-input {
            width: 100%;
            height: 180px;
            padding: 15px;
            border: 2px solid #d1d5db;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
            transition: all 0.3s ease;
        }
        
        .data-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.12);
        }
        
        .input-help {
            font-size: 12px;
            color: #6b7280;
            margin-top: 8px;
            line-height: 1.5;
        }
        
        .param-group {
            margin-bottom: 18px;
        }
        
        .param-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #374151;
            font-size: 14px;
        }
        
        .param-group input, .param-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .param-group input:focus, .param-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.12);
        }
        
        .param-unit {
            font-size: 11px;
            color: #6b7280;
            margin-top: 5px;
            font-style: italic;
        }
        
        .preset-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .preset-btn {
            padding: 12px 16px;
            background: #f1f5f9;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.25s ease;
            font-weight: 500;
            text-align: center;
        }
        
        .preset-btn:hover {
            background: #e2e8f0;
            border-color: #94a3b8;
            transform: translateY(-2px);
        }
        
        .analysis-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .tab-btn {
            flex: 1;
            padding: 15px;
            background: #f1f5f9;
            border: 2px solid #cbd5e1;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .tab-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }
        
        .tab-btn:hover:not(.active) {
            background: #e2e8f0;
            border-color: #94a3b8;
        }
        
        .analyze-btn {
            width: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 20px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 25px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }
        
        .analyze-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(102, 126, 234, 0.4);
        }
        
        .analyze-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .results-area {
            display: flex;
            flex-direction: column;
            background: white;
        }
        
        .stats-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 20px;
            padding: 30px;
            background: #f0f4ff;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .stat-card {
            text-align: center;
            padding: 20px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
            transition: transform 0.2s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-3px);
        }
        
        .stat-card.primary { border-left: 4px solid #667eea; }
        .stat-card.secondary { border-left: 4px solid #10b981; }
        .stat-card.tertiary { border-left: 4px solid #f59e0b; }
        .stat-card.quaternary { border-left: 4px solid #ef4444; }
        .stat-card.wavelet { border-left: 4px solid #8b5cf6; }
        
        .stat-label {
            font-size: 11px;
            color: #6b7280;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            font-weight: 500;
        }
        
        .stat-value {
            font-size: 22px;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
        }
        
        .stat-unit {
            font-size: 12px;
            color: #6b7280;
            font-weight: 400;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 400px 500px 400px;
            gap: 25px;
            padding: 30px;
        }
        
        .chart-box {
            background: #fafafa;
            border-radius: 15px;
            padding: 25px;
            border: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            box-shadow: 0 3px 10px rgba(0,0,0,0.06);
        }
        
        .chart-box.full-width {
            grid-column: 1 / -1;
        }
        
        .chart-box.wavelet-plot {
            grid-column: 1 / -1;
            grid-row: 2;
        }
        
        .chart-header {
            font-size: 1.4rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 20px;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .chart-content {
            flex: 1;
            position: relative;
        }
        
        .export-controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 18px;
        }
        
        .export-btn {
            padding: 10px 18px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        .export-btn:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }
        
        .peak-table {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
        }
        
        .peak-table table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        
        .peak-table th {
            background: #f8fafc;
            padding: 10px;
            text-align: left;
            font-weight: 600;
            color: #374151;
            border-bottom: 1px solid #e2e8f0;
            position: sticky;
            top: 0;
        }
        
        .peak-table td {
            padding: 8px 10px;
            border-bottom: 1px solid #f1f5f9;
        }
        
        .peak-table tr:hover {
            background: #f8fafc;
        }
        
        .error-message {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #dc2626;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 14px;
        }
        
        .success-message {
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            color: #166534;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 14px;
        }
        
        .wavelet-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .colorbar-info {
            font-size: 12px;
            color: #6b7280;
            text-align: center;
            margin-top: 10px;
            font-style: italic;
        }
        
        @media (max-width: 1400px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            
            .input-panel {
                border-right: none;
                border-bottom: 1px solid #e2e8f0;
                max-height: none;
            }
            
            .charts-container {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(6, 400px);
            }
            
            .chart-box.full-width, .chart-box.wavelet-plot {
                grid-column: 1;
            }
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2.5rem;
            }
            
            .stats-dashboard {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .analysis-tabs {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🌊 Advanced Time Series Analysis</h1>
            <p>Spectral Analysis & Continuous Wavelet Transform by Claudio Iturra</p>
            <div class="subtitle">FFT • CWT • Power Spectral Density • Time-Frequency Analysis • Peak Detection</div>
        </div>
        
        <div class="main-layout">
            <div class="input-panel">
                <div class="input-section">
                    <div class="section-title">
                        📈 Time Series Data
                    </div>
                    <textarea 
                        class="data-input" 
                        id="timeSeriesData" 
                        placeholder="Paste your time series data here...
Examples:
1.2, 1.5, 1.8, 2.1, 1.9, 1.6, 1.3, 1.0
OR
1.2
1.5
1.8
OR
2023-01-01 00:00, 1.2
2023-01-01 01:00, 1.5"></textarea>
                    <div class="input-help">
                        Supported formats: Comma-separated, line-separated, or timestamp,value pairs. 
                        Handles missing values automatically.
                    </div>
                    <div class="preset-section">
                        <button class="preset-btn" onclick="loadSampleData('tidal')">🌊 Tidal</button>
                        <button class="preset-btn" onclick="loadSampleData('temperature')">🌡️ Temperature</button>
                        <button class="preset-btn" onclick="loadSampleData('seismic')">🌍 Seismic</button>
                        <button class="preset-btn" onclick="loadSampleData('chirp')">📡 Chirp Signal</button>
                    </div>
                </div>
                
                <div class="input-section">
                    <div class="section-title">
                        ⏱️ Temporal Parameters
                    </div>
                    <div class="param-group">
                        <label for="temporalResolution">Temporal Resolution</label>
                        <input type="number" id="temporalResolution" value="60" step="1" min="1" max="1440">
                        <div class="param-unit">minutes between data points</div>
                    </div>
                    <div class="param-group">
                        <label for="dataUnits">Data Units</label>
                        <input type="text" id="dataUnits" value="m/s" placeholder="e.g., m/s, °C, m">
                        <div class="param-unit">for axis labeling</div>
                    </div>
                </div>
                
                <div class="input-section">
                    <div class="section-title">
                        🔧 Analysis Type
                    </div>
                    <div class="analysis-tabs">
                        <button class="tab-btn active" id="spectralTab" onclick="switchAnalysisType('spectral')">
                            📊 Spectral
                        </button>
                        <button class="tab-btn" id="waveletTab" onclick="switchAnalysisType('wavelet')">
                            🌊 Wavelet
                        </button>
                    </div>
                </div>
                
                <div class="input-section" id="spectralParams">
                    <div class="section-title">
                        📊 Spectral Parameters
                    </div>
                    <div class="param-group">
                        <label for="windowFunction">Window Function</label>
                        <select id="windowFunction">
                            <option value="hanning">Hanning</option>
                            <option value="hamming">Hamming</option>
                            <option value="blackman">Blackman</option>
                            <option value="bartlett">Bartlett</option>
                            <option value="rectangular">Rectangular</option>
                        </select>
                    </div>
                    <div class="param-group">
                        <label for="detrend">Detrend Method</label>
                        <select id="detrend">
                            <option value="linear">Linear</option>
                            <option value="constant">Remove Mean</option>
                            <option value="none">None</option>
                        </select>
                    </div>
                    <div class="param-group">
                        <label for="zeroPadding">Zero Padding Factor</label>
                        <select id="zeroPadding">
                            <option value="1">None (1x)</option>
                            <option value="2" selected>2x</option>
                            <option value="4">4x</option>
                            <option value="8">8x</option>
                        </select>
                    </div>
                    <div class="param-group">
                        <label for="peakThreshold">Peak Detection Threshold</label>
                        <input type="number" id="peakThreshold" value="0.1" step="0.01" min="0.01" max="1">
                        <div class="param-unit">relative to maximum power</div>
                    </div>
                </div>
                
                <div class="input-section" id="waveletParams" style="display: none;">
                    <div class="section-title">
                        🌊 Wavelet Parameters
                    </div>
                    <div class="param-group">
                        <label for="waveletType">Wavelet Type</label>
                        <select id="waveletType">
                            <option value="morlet" selected>Morlet</option>
                            <option value="paul">Paul</option>
                            <option value="dog">DOG (Mexican Hat)</option>
                        </select>
                    </div>
                    <div class="param-group">
                        <label for="waveletParam">Wavelet Parameter</label>
                        <input type="number" id="waveletParam" value="6" step="0.5" min="1" max="20">
                        <div class="param-unit">ω₀ for Morlet, m for Paul/DOG</div>
                    </div>
                    <div class="param-group">
                        <label for="scaleMin">Minimum Scale</label>
                        <input type="number" id="scaleMin" value="2" step="0.5" min="1" max="100">
                        <div class="param-unit">minimum period in data points</div>
                    </div>
                    <div class="param-group">
                        <label for="scaleMax">Maximum Scale</label>
                        <input type="number" id="scaleMax" value="100" step="1" min="10" max="1000">
                        <div class="param-unit">maximum period in data points</div>
                    </div>
                    <div class="param-group">
                        <label for="scaleSteps">Scale Steps</label>
                        <input type="number" id="scaleSteps" value="50" step="1" min="20" max="200">
                        <div class="param-unit">number of frequency bands</div>
                    </div>
                </div>
                
                <div class="input-section">
                    <div class="section-title">
                        📊 Display Options
                    </div>
                    <div class="param-group">
                        <label for="frequencyUnits">Frequency Units</label>
                        <select id="frequencyUnits">
                            <option value="cpd" selected>Cycles per Day</option>
                            <option value="cph">Cycles per Hour</option>
                            <option value="hz">Hz (cycles/second)</option>
                            <option value="period_hours">Period (hours)</option>
                            <option value="period_days">Period (days)</option>
                        </select>
                    </div>
                    <div class="param-group">
                        <label for="powerScale">Power Scale</label>
                        <select id="powerScale">
                            <option value="linear">Linear</option>
                            <option value="log" selected>Logarithmic</option>
                        </select>
                    </div>
                    <div class="param-group">
                        <label for="maxFrequency">Maximum Frequency</label>
                        <input type="number" id="maxFrequency" value="10" step="0.5" min="0.1" max="100">
                        <div class="param-unit">cycles per day</div>
                    </div>
                </div>
                
                <button class="analyze-btn" id="analyzeBtn" onclick="performAnalysis()">
                    🔬 Analyze Time Series
                </button>
                
                <div id="statusMessage"></div>
            </div>
            
            <div class="results-area">
                <div class="stats-dashboard" id="statsDashboard">
                    <!-- Statistics will be populated here -->
                </div>
                
                <div class="charts-container">
                    <div class="chart-box">
                        <div class="chart-header">Time Series Data</div>
                        <div class="chart-content">
                            <canvas id="timeSeriesChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-box">
                        <div class="chart-header" id="analysisChartHeader">Power Spectral Density</div>
                        <div class="chart-content">
                            <canvas id="analysisChart"></canvas>
                        </div>
                        <div class="export-controls">
                            <button class="export-btn" onclick="exportResults()">📊 Export Data</button>
                            <button class="export-btn" onclick="exportPeaks()">🎯 Export Peaks</button>
                        </div>
                    </div>
                    
                    <div class="chart-box wavelet-plot">
                        <div class="chart-header">Wavelet Transform / Scalogram</div>
                        <div class="chart-content">
                            <div id="waveletPlot" style="width: 100%; height: 100%;"></div>
                        </div>
                        <div class="colorbar-info">
                            Color intensity represents wavelet power magnitude
                        </div>
                    </div>
                    
                    <div class="chart-box">
                        <div class="chart-header">Global Wavelet Spectrum</div>
                        <div class="chart-content">
                            <canvas id="globalWaveletChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-box full-width">
                        <div class="chart-header">Detected Peaks & Significant Frequencies</div>
                        <div class="chart-content">
                            <div class="peak-table" id="peakTable">
                                <!-- Peak table will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let timeSeriesChart = null;
        let analysisChart = null;
        let globalWaveletChart = null;
        let analysisResults = null;
        let currentAnalysisType = 'spectral';
        
        // Complex number operations
        class Complex {
            constructor(real, imag = 0) {
                this.real = real;
                this.imag = imag;
            }
            
            add(other) {
                return new Complex(this.real + other.real, this.imag + other.imag);
            }
            
            multiply(other) {
                return new Complex(
                    this.real * other.real - this.imag * other.imag,
                    this.real * other.imag + this.imag * other.real
                );
            }
            
            magnitude() {
                return Math.sqrt(this.real * this.real + this.imag * this.imag);
            }
            
            phase() {
                return Math.atan2(this.imag, this.real);
            }
        }
        
        // FFT implementation
        function fft(signal) {
            const N = signal.length;
            if (N <= 1) return signal.map(x => new Complex(x));
            
            const nextPow2 = Math.pow(2, Math.ceil(Math.log2(N)));
            const paddedSignal = [...signal];
            while (paddedSignal.length < nextPow2) {
                paddedSignal.push(0);
            }
            
            return fftRecursive(paddedSignal.map(x => new Complex(x)));
        }
        
        function fftRecursive(x) {
            const N = x.length;
            if (N <= 1) return x;
            
            const even = fftRecursive(x.filter((_, i) => i % 2 === 0));
            const odd = fftRecursive(x.filter((_, i) => i % 2 === 1));
            
            const result = new Array(N);
            for (let k = 0; k < N/2; k++) {
                const angle = -2 * Math.PI * k / N;
                const t = new Complex(Math.cos(angle), Math.sin(angle)).multiply(odd[k]);
                result[k] = even[k].add(t);
                result[k + N/2] = even[k].add(t.multiply(new Complex(-1, 0)));
            }
            return result;
        }
        
        // Wavelet functions
        function morletWavelet(t, s, w0 = 6) {
            const norm = Math.pow(Math.PI, -0.25) * Math.sqrt(2 / s);
            const exp1 = Math.exp(-0.5 * Math.pow(t / s, 2));
            const exp2 = Math.exp(new Complex(0, w0 * t / s));
            return norm * exp1 * Math.cos(w0 * t / s);
        }
        
        function paulWavelet(t, s, m = 4) {
            const norm = Math.sqrt(2 * Math.PI * s / m) * Math.pow(2, m) / Math.sqrt(Math.PI * factorial(2 * m - 1));
            const factor = Math.pow(1 + new Complex(0, t / s), -m - 1);
            return norm * factor;
        }
        
        function dogWavelet(t, s, m = 2) {
            const norm = Math.pow(-1, m + 1) / Math.sqrt(gamma(m + 0.5)) * Math.sqrt(s);
            const factor = Math.pow(t / s, m) * Math.exp(-0.5 * Math.pow(t / s, 2));
            return norm * factor;
        }
        
        function factorial(n) {
            if (n <= 1) return 1;
            return n * factorial(n - 1);
        }
        
        function gamma(z) {
            // Approximation for gamma function
            if (z === 0.5) return Math.sqrt(Math.PI);
            if (z === 1.5) return 0.5 * Math.sqrt(Math.PI);
            if (z === 2.5) return 0.75 * Math.sqrt(Math.PI);
            return factorial(Math.floor(z) - 1);
        }
        
        // Continuous Wavelet Transform
        function cwt(signal, scales, waveletType = 'morlet', param = 6) {
            const N = signal.length;
            const result = [];
            
            for (let scaleIdx = 0; scaleIdx < scales.length; scaleIdx++) {
                const scale = scales[scaleIdx];
                const convolution = new Array(N);
                
                for (let n = 0; n < N; n++) {
                    let sum = 0;
                    
                    for (let k = 0; k < N; k++) {
                        const t = k - n;
                        let waveletValue = 0;
                        
                        switch (waveletType) {
                            case 'morlet':
                                waveletValue = morletWavelet(t, scale, param);
                                break;
                            case 'paul':
                                waveletValue = paulWavelet(t, scale, param);
                                break;
                            case 'dog':
                                waveletValue = dogWavelet(t, scale, param);
                                break;
                        }
                        
                        sum += signal[k] * waveletValue;
                    }
                    
                    convolution[n] = Math.abs(sum);
                }
                
                result.push(convolution);
            }
            
            return result;
        }
        
        function switchAnalysisType(type) {
            currentAnalysisType = type;
            
            // Update tab appearance
            document.getElementById('spectralTab').classList.toggle('active', type === 'spectral');
            document.getElementById('waveletTab').classList.toggle('active', type === 'wavelet');
            
            // Show/hide parameter sections
            document.getElementById('spectralParams').style.display = type === 'spectral' ? 'block' : 'none';
            document.getElementById('waveletParams').style.display = type === 'wavelet' ? 'block' : 'none';
            
            // Update button text
            const btn = document.getElementById('analyzeBtn');
            btn.innerHTML = type === 'spectral' ? '🔬 Analyze Spectrum' : '🌊 Analyze Wavelets';
        }
        
        function loadSampleData(type) {
            const samples = {
                'tidal': generateTidalData(),
                'temperature': generateTemperatureData(),
                'seismic': generateSeismicData(),
                'chirp': generateChirpSignal()
            };
            
            document.getElementById('timeSeriesData').value = samples[type];
            
            const params = {
                'tidal': { resolution: 60, units: 'm/s' },
                'temperature': { resolution: 30, units: '°C' },
                'seismic': { resolution: 1, units: 'm/s²' },
                'chirp': { resolution: 10, units: 'amplitude' }
            };
            
            document.getElementById('temporalResolution').value = params[type].resolution;
            document.getElementById('dataUnits').value = params[type].units;
        }
        
        function generateTidalData() {
            const data = [];
            const hours = 336; // 14 days
            
            for (let i = 0; i < hours; i++) {
                const t = i;
                // Multiple tidal components
                const m2 = 1.5 * Math.cos(2 * Math.PI * t / 12.42); // M2 tide
                const s2 = 0.4 * Math.cos(2 * Math.PI * t / 12 + Math.PI/3); // S2 tide
                const m4 = 0.3 * Math.cos(2 * Math.PI * t / 6.21 + Math.PI/4); // M4 tide
                const o1 = 0.2 * Math.cos(2 * Math.PI * t / 25.82 + Math.PI/6); // O1 tide
                const noise = 0.1 * (Math.random() - 0.5);
                
                data.push((m2 + s2 + m4 + o1 + noise).toFixed(3));
            }
            
            return data.join('\n');
        }
        
        function generateTemperatureData() {
            const data = [];
            const hours = 720; // 30 days
            
            for (let i = 0; i < hours; i++) {
                const t = i * 0.5; // 30-minute intervals
                const daily = 8 * Math.cos(2 * Math.PI * t / 24 - Math.PI/2);
                const weekly = 3 * Math.cos(2 * Math.PI * t / (24 * 7));
                const seasonal = 1 * Math.cos(2 * Math.PI * t / (24 * 30));
                const trend = 0.005 * t;
                const noise = 1 * (Math.random() - 0.5);
                
                const temp = 15 + daily + weekly + seasonal + trend + noise;
                data.push(temp.toFixed(2));
            }
            
            return data.join('\n');
        }
        
        function generateSeismicData() {
            const data = [];
            const points = 1000;
            
            for (let i = 0; i < points; i++) {
                const t = i;
                let signal = 0;
                
                // Background noise
                signal += 0.1 * (Math.random() - 0.5);
                
                // Seismic events at different times
                if (t > 200 && t < 250) {
                    signal += 2 * Math.exp(-(t - 225) * (t - 225) / 100) * Math.cos(2 * Math.PI * t / 8);
                }
                if (t > 600 && t < 700) {
                    signal += 1.5 * Math.exp(-(t - 650) * (t - 650) / 200) * Math.cos(2 * Math.PI * t / 12);
                }
                
                data.push(signal.toFixed(4));
            }
            
            return data.join('\n');
        }
        
        function generateChirpSignal() {
            const data = [];
            const points = 500;
            
            for (let i = 0; i < points; i++) {
                const t = i / points;
                // Frequency increases linearly from 1 to 20 cycles per unit time
                const freq = 1 + 19 * t;
                const phase = 2 * Math.PI * (t + 9.5 * t * t);
                const signal = Math.cos(phase) + 0.1 * (Math.random() - 0.5);
                
                data.push(signal.toFixed(4));
            }
            
            return data.join('\n');
        }
        
        function parseTimeSeriesData(dataText) {
            const lines = dataText.trim().split('\n');
            const values = [];
            const timestamps = [];
            
            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                
                if (line.includes(',')) {
                    const parts = line.split(',');
                    if (parts.length === 2 && isNaN(parts[0])) {
                        timestamps.push(parts[0].trim());
                        values.push(parseFloat(parts[1].trim()));
                    } else {
                        for (let part of parts) {
                            const val = parseFloat(part.trim());
                            if (!isNaN(val)) values.push(val);
                        }
                    }
                } else {
                    const val = parseFloat(line);
                    if (!isNaN(val)) values.push(val);
                }
            }
            
            return { values, timestamps };
        }
        
        function applyWindow(data, windowType) {
            const N = data.length;
            const windowed = new Array(N);
            
            for (let i = 0; i < N; i++) {
                let w = 1;
                const n = i / (N - 1);
                
                switch (windowType) {
                    case 'hanning':
                        w = 0.5 * (1 - Math.cos(2 * Math.PI * n));
                        break;
                    case 'hamming':
                        w = 0.54 - 0.46 * Math.cos(2 * Math.PI * n);
                        break;
                    case 'blackman':
                        w = 0.42 - 0.5 * Math.cos(2 * Math.PI * n) + 0.08 * Math.cos(4 * Math.PI * n);
                        break;
                    case 'bartlett':
                        w = 1 - Math.abs(2 * n - 1);
                        break;
                    case 'rectangular':
                    default:
                        w = 1;
                        break;
                }
                
                windowed[i] = data[i] * w;
            }
            
            return windowed;
        }
        
        function detrend(data, method) {
            const N = data.length;
            const detrended = [...data];
            
            if (method === 'constant') {
                const mean = data.reduce((sum, val) => sum + val, 0) / N;
                for (let i = 0; i < N; i++) {
                    detrended[i] -= mean;
                }
            } else if (method === 'linear') {
                const sumX = N * (N - 1) / 2;
                const sumX2 = N * (N - 1) * (2 * N - 1) / 6;
                const sumY = data.reduce((sum, val) => sum + val, 0);
                const sumXY = data.reduce((sum, val, i) => sum + i * val, 0);
                
                const slope = (N * sumXY - sumX * sumY) / (N * sumX2 - sumX * sumX);
                const intercept = (sumY - slope * sumX) / N;
                
                for (let i = 0; i < N; i++) {
                    detrended[i] -= (slope * i + intercept);
                }
            }
            
            return detrended;
        }
        
        function findPeaks(spectrum, frequencies, threshold) {
            const peaks = [];
            const maxPower = Math.max(...spectrum);
            const minPower = maxPower * threshold;
            
            for (let i = 1; i < spectrum.length - 1; i++) {
                if (spectrum[i] > spectrum[i-1] && 
                    spectrum[i] > spectrum[i+1] && 
                    spectrum[i] > minPower) {
                    
                    peaks.push({
                        frequency: frequencies[i],
                        power: spectrum[i],
                        index: i,
                        amplitude: Math.sqrt(spectrum[i])
                    });
                }
            }
            
            peaks.sort((a, b) => b.power - a.power);
            return peaks;
        }
        
        function convertFrequency(freq, fromUnit, toUnit, temporalResolution) {
            let freqHz = freq;
            
            if (fromUnit === 'cpd') {
                freqHz = freq / (24 * 3600);
            } else if (fromUnit === 'cph') {
                freqHz = freq / 3600;
            }
            
            if (toUnit === 'cpd') {
                return freqHz * 24 * 3600;
            } else if (toUnit === 'cph') {
                return freqHz * 3600;
            } else if (toUnit === 'hz') {
                return freqHz;
            } else if (toUnit === 'period_hours') {
                return freqHz > 0 ? 1 / (freqHz * 3600) : Infinity;
            } else if (toUnit === 'period_days') {
                return freqHz > 0 ? 1 / (freqHz * 24 * 3600) : Infinity;
            }
            
            return freq;
        }
        
        function performAnalysis() {
            const dataText = document.getElementById('timeSeriesData').value.trim();
            if (!dataText) {
                showMessage('Please enter time series data.', 'error');
                return;
            }
            
            try {
                const { values } = parseTimeSeriesData(dataText);
                if (values.length < 4) {
                    showMessage('Need at least 4 data points for analysis.', 'error');
                    return;
                }
                
                const temporalResolution = parseFloat(document.getElementById('temporalResolution').value);
                const frequencyUnits = document.getElementById('frequencyUnits').value;
                
                showMessage(`Performing ${currentAnalysisType} analysis...`, 'info');
                
                if (currentAnalysisType === 'spectral') {
                    performSpectralAnalysis(values, temporalResolution, frequencyUnits);
                } else {
                    performWaveletAnalysis(values, temporalResolution, frequencyUnits);
                }
                
            } catch (error) {
                console.error('Analysis error:', error);
                showMessage(`Analysis failed: ${error.message}`, 'error');
            }
        }
        
        function performSpectralAnalysis(values, temporalResolution, frequencyUnits) {
            // Get spectral parameters
            const windowFunction = document.getElementById('windowFunction').value;
            const detrendMethod = document.getElementById('detrend').value;
            const zeroPadding = parseInt(document.getElementById('zeroPadding').value);
            const peakThreshold = parseFloat(document.getElementById('peakThreshold').value);
            
            // Preprocess data
            let processedData = [...values];
            processedData = processedData.filter(val => !isNaN(val));
            
            if (detrendMethod !== 'none') {
                processedData = detrend(processedData, detrendMethod);
            }
            
            processedData = applyWindow(processedData, windowFunction);
            
            const originalLength = processedData.length;
            const paddedLength = originalLength * zeroPadding;
            while (processedData.length < paddedLength) {
                processedData.push(0);
            }
            
            // Perform FFT
            const fftResult = fft(processedData);
            
            // Calculate power spectral density
            const N = fftResult.length;
            const spectrum = new Array(Math.floor(N/2));
            const dt = temporalResolution * 60; // seconds
            const df = 1 / (N * dt); // frequency resolution in Hz
            
            for (let i = 0; i < spectrum.length; i++) {
                const magnitude = fftResult[i].magnitude();
                spectrum[i] = (magnitude * magnitude) / (N * N);
                
                if (i > 0 && i < spectrum.length - 1) {
                    spectrum[i] *= 2;
                }
            }
            
            // Create frequency array
            const frequencies = new Array(spectrum.length);
            for (let i = 0; i < frequencies.length; i++) {
                frequencies[i] = i * df;
            }
            
            const displayFrequencies = frequencies.map(f => 
                convertFrequency(f, 'hz', frequencyUnits, temporalResolution)
            );
            
            const peaks = findPeaks(spectrum, displayFrequencies, peakThreshold);
            
            analysisResults = {
                type: 'spectral',
                originalData: values,
                processedData: processedData.slice(0, originalLength),
                spectrum: spectrum,
                frequencies: displayFrequencies,
                peaks: peaks,
                parameters: {
                    temporalResolution,
                    windowFunction,
                    detrendMethod,
                    zeroPadding,
                    frequencyUnits,
                    originalLength,
                    paddedLength: N
                }
            };
            
            updateStatistics();
            createTimeSeriesChart();
            createSpectralChart();
            createPeakTable();
            
            showMessage(`Spectral analysis complete! Found ${peaks.length} significant peaks.`, 'success');
        }
        
        function performWaveletAnalysis(values, temporalResolution, frequencyUnits) {
            // Get wavelet parameters
            const waveletType = document.getElementById('waveletType').value;
            const waveletParam = parseFloat(document.getElementById('waveletParam').value);
            const scaleMin = parseFloat(document.getElementById('scaleMin').value);
            const scaleMax = parseFloat(document.getElementById('scaleMax').value);
            const scaleSteps = parseInt(document.getElementById('scaleSteps').value);
            
            // Preprocess data
            let processedData = [...values];
            processedData = processedData.filter(val => !isNaN(val));
            
            // Remove mean
            const mean = processedData.reduce((sum, val) => sum + val, 0) / processedData.length;
            processedData = processedData.map(val => val - mean);
            
            // Create scale array (logarithmic spacing)
            const scales = [];
            const logMin = Math.log(scaleMin);
            const logMax = Math.log(scaleMax);
            for (let i = 0; i < scaleSteps; i++) {
                const logScale = logMin + (logMax - logMin) * i / (scaleSteps - 1);
                scales.push(Math.exp(logScale));
            }
            
            // Perform CWT
            const waveletCoeffs = cwt(processedData, scales, waveletType, waveletParam);
            
            // Convert scales to frequencies
            const dt = temporalResolution * 60; // seconds
            const frequencies = scales.map(scale => {
                // Approximate relationship between scale and frequency
                let freqFactor = 1;
                if (waveletType === 'morlet') {
                    freqFactor = waveletParam / (2 * Math.PI);
                } else if (waveletType === 'paul') {
                    freqFactor = 2 * waveletParam / (2 * waveletParam + 1);
                } else if (waveletType === 'dog') {
                    freqFactor = Math.sqrt(2 * waveletParam + 1) / (2 * Math.PI);
                }
                
                const freqHz = freqFactor / (scale * dt);
                return convertFrequency(freqHz, 'hz', frequencyUnits, temporalResolution);
            });
            
            // Calculate global wavelet spectrum (time-averaged)
            const globalSpectrum = new Array(scales.length);
            for (let i = 0; i < scales.length; i++) {
                const sum = waveletCoeffs[i].reduce((acc, val) => acc + val * val, 0);
                globalSpectrum[i] = sum / waveletCoeffs[i].length;
            }
            
            // Find peaks in global spectrum
            const peaks = findPeaks(globalSpectrum, frequencies, 0.1);
            
            analysisResults = {
                type: 'wavelet',
                originalData: values,
                processedData: processedData,
                waveletCoeffs: waveletCoeffs,
                scales: scales,
                frequencies: frequencies,
                globalSpectrum: globalSpectrum,
                peaks: peaks,
                parameters: {
                    temporalResolution,
                    waveletType,
                    waveletParam,
                    scaleMin,
                    scaleMax,
                    scaleSteps,
                    frequencyUnits
                }
            };
            
            updateStatistics();
            createTimeSeriesChart();
            createWaveletPlot();
            createGlobalWaveletChart();
            createPeakTable();
            
            showMessage(`Wavelet analysis complete! Found ${peaks.length} significant peaks.`, 'success');
        }
        
        function updateStatistics() {
            if (!analysisResults) return;
            
            const { originalData, parameters } = analysisResults;
            const units = document.getElementById('dataUnits').value;
            const freqUnits = getFrequencyUnitLabel();
            
            // Basic statistics
            const mean = originalData.reduce((sum, val) => sum + val, 0) / originalData.length;
            const variance = originalData.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / originalData.length;
            const std = Math.sqrt(variance);
            const min = Math.min(...originalData);
            const max = Math.max(...originalData);
            
            let statsHTML = `
                <div class="stat-card primary">
                    <div class="stat-label">Data Points</div>
                    <div class="stat-value">${originalData.length}</div>
                    <div class="stat-unit">samples</div>
                </div>
                <div class="stat-card primary">
                    <div class="stat-label">Mean Value</div>
                    <div class="stat-value">${mean.toFixed(3)}</div>
                    <div class="stat-unit">${units}</div>
                </div>
                <div class="stat-card primary">
                    <div class="stat-label">Std Deviation</div>
                    <div class="stat-value">${std.toFixed(3)}</div>
                    <div class="stat-unit">${units}</div>
                </div>
                <div class="stat-card secondary">
                    <div class="stat-label">Min Value</div>
                    <div class="stat-value">${min.toFixed(3)}</div>
                    <div class="stat-unit">${units}</div>
                </div>
                <div class="stat-card secondary">
                    <div class="stat-label">Max Value</div>
                    <div class="stat-value">${max.toFixed(3)}</div>
                    <div class="stat-unit">${units}</div>
                </div>
            `;
            
            if (analysisResults.type === 'spectral') {
                const { spectrum, frequencies } = analysisResults;
                const freqResolution = frequencies[1] - frequencies[0];
                const nyquistFreq = frequencies[frequencies.length - 1];
                const totalPower = spectrum.reduce((sum, val) => sum + val, 0);
                
                statsHTML += `
                    <div class="stat-card tertiary">
                        <div class="stat-label">Freq Resolution</div>
                        <div class="stat-value">${freqResolution.toFixed(4)}</div>
                        <div class="stat-unit">${freqUnits}</div>
                    </div>
                    <div class="stat-card tertiary">
                        <div class="stat-label">Nyquist Freq</div>
                        <div class="stat-value">${nyquistFreq.toFixed(3)}</div>
                        <div class="stat-unit">${freqUnits}</div>
                    </div>
                    <div class="stat-card quaternary">
                        <div class="stat-label">Total Power</div>
                        <div class="stat-value">${totalPower.toExponential(2)}</div>
                        <div class="stat-unit">${units}²</div>
                    </div>
                `;
            } else if (analysisResults.type === 'wavelet') {
                const { scales, frequencies, globalSpectrum } = analysisResults;
                const minFreq = Math.min(...frequencies);
                const maxFreq = Math.max(...frequencies);
                const totalPower = globalSpectrum.reduce((sum, val) => sum + val, 0);
                
                statsHTML += `
                    <div class="stat-card wavelet">
                        <div class="stat-label">Scale Range</div>
                        <div class="stat-value">${scales[0].toFixed(1)}-${scales[scales.length-1].toFixed(1)}</div>
                        <div class="stat-unit">scale units</div>
                    </div>
                    <div class="stat-card wavelet">
                        <div class="stat-label">Freq Range</div>
                        <div class="stat-value">${minFreq.toFixed(3)}-${maxFreq.toFixed(3)}</div>
                        <div class="stat-unit">${freqUnits}</div>
                    </div>
                    <div class="stat-card quaternary">
                        <div class="stat-label">Total Power</div>
                        <div class="stat-value">${totalPower.toExponential(2)}</div>
                        <div class="stat-unit">${units}²</div>
                    </div>
                `;
            }
            
            statsHTML += `
                <div class="stat-card quaternary">
                    <div class="stat-label">Detected Peaks</div>
                    <div class="stat-value">${analysisResults.peaks.length}</div>
                    <div class="stat-unit">peaks</div>
                </div>
            `;
            
            document.getElementById('statsDashboard').innerHTML = statsHTML;
        }
        
        function getFrequencyUnitLabel() {
            const unit = document.getElementById('frequencyUnits').value;
            const labels = {
                'cpd': 'cycles/day',
                'cph': 'cycles/hour',
                'hz': 'Hz',
                'period_hours': 'hours',
                'period_days': 'days'
            };
            return labels[unit] || 'Hz';
        }
        
        function createTimeSeriesChart() {
            const ctx = document.getElementById('timeSeriesChart').getContext('2d');
            
            if (timeSeriesChart) {
                timeSeriesChart.destroy();
            }
            
            const { originalData, processedData, parameters } = analysisResults;
            const temporalResolution = parameters.temporalResolution;
            const units = document.getElementById('dataUnits').value;
            
            const timePoints = originalData.map((_, i) => i * temporalResolution / 60);
            
            const datasets = [
                {
                    label: 'Original Data',
                    data: originalData,
                    borderColor: '#667eea',
                    backgroundColor: 'rgba(102, 126, 234, 0.1)',
                    borderWidth: 2,
                    pointRadius: 1,
                    fill: false
                }
            ];
            
            if (analysisResults.type === 'spectral' && processedData) {
                datasets.push({
                    label: 'Processed Data',
                    data: processedData,
                    borderColor: '#10b981',
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    borderWidth: 2,
                    pointRadius: 1,
                    fill: false,
                    borderDash: [5, 5]
                });
            }
            
            timeSeriesChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timePoints,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top' }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Time (hours)' },
                            grid: { alpha: 0.3 }
                        },
                        y: {
                            title: { display: true, text: `Value (${units})` },
                            grid: { alpha: 0.3 }
                        }
                    }
                }
            });
        }
        
        function createSpectralChart() {
            const ctx = document.getElementById('analysisChart').getContext('2d');
            
            if (analysisChart) {
                analysisChart.destroy();
            }
            
            const { spectrum, frequencies, peaks } = analysisResults;
            const powerScale = document.getElementById('powerScale').value;
            const maxFreq = parseFloat(document.getElementById('maxFrequency').value);
            const freqUnits = getFrequencyUnitLabel();
            const units = document.getElementById('dataUnits').value;
            
            // Filter data for display range
            const displayIndices = frequencies.map((f, i) => f <= maxFreq ? i : -1).filter(i => i >= 0);
            const displayFreqs = displayIndices.map(i => frequencies[i]);
            const displaySpectrum = displayIndices.map(i => spectrum[i]);
            
            const peakData = peaks
                .filter(peak => peak.frequency <= maxFreq)
                .map(peak => ({
                    x: peak.frequency,
                    y: peak.power
                }));
            
            document.getElementById('analysisChartHeader').textContent = 'Power Spectral Density';
            
            analysisChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: displayFreqs,
                    datasets: [
                        {
                            label: 'Power Spectral Density',
                            data: displaySpectrum,
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.2)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: true
                        },
                        {
                            label: 'Detected Peaks',
                            data: peakData,
                            borderColor: '#ef4444',
                            backgroundColor: '#ef4444',
                            borderWidth: 0,
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            showLine: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top' }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: `Frequency (${freqUnits})` },
                            grid: { alpha: 0.3 }
                        },
                        y: {
                            title: { display: true, text: `Power (${units}²)` },
                            type: powerScale === 'log' ? 'logarithmic' : 'linear',
                            grid: { alpha: 0.3 }
                        }
                    }
                }
            });
        }
        
        function createWaveletPlot() {
            const { waveletCoeffs, frequencies, parameters } = analysisResults;
            const temporalResolution = parameters.temporalResolution;
            const freqUnits = getFrequencyUnitLabel();
            
            // Prepare data for Plotly
            const timePoints = waveletCoeffs[0].map((_, i) => i * temporalResolution / 60);
            
            // Create 2D array for heatmap
            const zData = waveletCoeffs.map(row => row.map(val => Math.log10(val + 1e-10)));
            
            const trace = {
                x: timePoints,
                y: frequencies,
                z: zData,
                type: 'heatmap',
                colorscale: 'Viridis',
                showscale: true,
                colorbar: {
                    title: 'log₁₀(Power)',
                    titleside: 'right'
                }
            };
            
            const layout = {
                title: 'Continuous Wavelet Transform',
                xaxis: {
                    title: 'Time (hours)',
                    showgrid: true
                },
                yaxis: {
                    title: `Frequency (${freqUnits})`,
                    showgrid: true,
                    type: 'log'
                },
                margin: { l: 80, r: 80, t: 50, b: 80 }
            };
            
            Plotly.newPlot('waveletPlot', [trace], layout, {responsive: true});
        }
        
        function createGlobalWaveletChart() {
            const ctx = document.getElementById('globalWaveletChart').getContext('2d');
            
            if (globalWaveletChart) {
                globalWaveletChart.destroy();
            }
            
            const { globalSpectrum, frequencies, peaks } = analysisResults;
            const freqUnits = getFrequencyUnitLabel();
            const units = document.getElementById('dataUnits').value;
            
            const peakData = peaks.map(peak => ({
                x: peak.frequency,
                y: peak.power
            }));
            
            globalWaveletChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: frequencies,
                    datasets: [
                        {
                            label: 'Global Wavelet Spectrum',
                            data: globalSpectrum,
                            borderColor: '#8b5cf6',
                            backgroundColor: 'rgba(139, 92, 246, 0.2)',
                            borderWidth: 3,
                            pointRadius: 0,
                            fill: true
                        },
                        {
                            label: 'Detected Peaks',
                            data: peakData,
                            borderColor: '#ef4444',
                            backgroundColor: '#ef4444',
                            borderWidth: 0,
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            showLine: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top' }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: `Frequency (${freqUnits})` },
                            type: 'logarithmic',
                            grid: { alpha: 0.3 }
                        },
                        y: {
                            title: { display: true, text: `Power (${units}²)` },
                            type: 'logarithmic',
                            grid: { alpha: 0.3 }
                        }
                    }
                }
            });
        }
        
        function createPeakTable() {
            const { peaks } = analysisResults;
            const freqUnits = getFrequencyUnitLabel();
            const units = document.getElementById('dataUnits').value;
            
            let tableHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Frequency</th>
                            <th>Period</th>
                            <th>Power</th>
                            <th>Amplitude</th>
                            <th>% of Max</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            const maxPower = peaks.length > 0 ? peaks[0].power : 1;
            
            peaks.slice(0, 20).forEach((peak, index) => {
                const period = peak.frequency > 0 ? 1 / peak.frequency : Infinity;
                const periodStr = period === Infinity ? '∞' : period.toFixed(3);
                const powerPercent = (peak.power / maxPower * 100).toFixed(1);
                
                tableHTML += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${peak.frequency.toFixed(4)} ${freqUnits}</td>
                        <td>${periodStr}</td>
                        <td>${peak.power.toExponential(3)}</td>
                        <td>${peak.amplitude.toFixed(4)} ${units}</td>
                        <td>${powerPercent}%</td>
                    </tr>
                `;
            });
            
            tableHTML += '</tbody></table>';
            
            document.getElementById('peakTable').innerHTML = tableHTML;
        }
        
        function exportResults() {
            if (!analysisResults) {
                showMessage('No analysis results to export.', 'error');
                return;
            }
            
            const freqUnits = getFrequencyUnitLabel();
            const units = document.getElementById('dataUnits').value;
            let csvContent = '';
            
            if (analysisResults.type === 'spectral') {
                const { spectrum, frequencies } = analysisResults;
                csvContent = `Frequency (${freqUnits}),Power (${units}²)\n`;
                
                for (let i = 0; i < spectrum.length; i++) {
                    csvContent += `${frequencies[i]},${spectrum[i]}\n`;
                }
                
                downloadCSV(csvContent, 'spectral_analysis.csv');
            } else if (analysisResults.type === 'wavelet') {
                const { globalSpectrum, frequencies } = analysisResults;
                csvContent = `Frequency (${freqUnits}),Global_Power (${units}²)\n`;
                
                for (let i = 0; i < globalSpectrum.length; i++) {
                    csvContent += `${frequencies[i]},${globalSpectrum[i]}\n`;
                }
                
                downloadCSV(csvContent, 'wavelet_analysis.csv');
            }
        }
        
        function exportPeaks() {
            if (!analysisResults) {
                showMessage('No analysis results to export.', 'error');
                return;
            }
            
            const { peaks } = analysisResults;
            const freqUnits = getFrequencyUnitLabel();
            const units = document.getElementById('dataUnits').value;
            
            let csvContent = `Rank,Frequency (${freqUnits}),Period,Power (${units}²),Amplitude (${units})\n`;
            
            peaks.forEach((peak, index) => {
                const period = peak.frequency > 0 ? 1 / peak.frequency : 'Infinity';
                csvContent += `${index + 1},${peak.frequency},${period},${peak.power},${peak.amplitude}\n`;
            });
            
            downloadCSV(csvContent, 'detected_peaks.csv');
        }
        
        function downloadCSV(content, filename) {
            const blob = new Blob([content], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
        
        function showMessage(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            const className = type === 'error' ? 'error-message' : 
                            type === 'success' ? 'success-message' : 'info-message';
            
            statusDiv.innerHTML = `<div class="${className}">${message}</div>`;
            
            if (type !== 'error') {
                setTimeout(() => {
                    statusDiv.innerHTML = '';
                }, 5000);
            }
        }
        
        // Initialize with sample data
        loadSampleData('tidal');
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'96b8e3ad309c88ac',t:'MTc1NDU5MTg4OS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Series SVD Analysis</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .content {
            padding: 30px;
        }
        
        .input-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 4px solid #667eea;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        textarea, input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            box-sizing: border-box;
        }
        
        textarea:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        textarea {
            height: 120px;
            resize: vertical;
            font-family: 'Courier New', monospace;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .results-section {
            margin-top: 30px;
        }
        
        .equation-box {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Times New Roman', serif;
        }
        
        .equation-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        
        .equation {
            font-size: 16px;
            line-height: 1.6;
            text-align: center;
            margin: 10px 0;
        }
        
        .plot-container {
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .mode-info {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }
        
        .error {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #e74c3c;
            margin: 15px 0;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-size: 1.1em;
        }
        
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            
            .content {
                padding: 20px;
            }
            
            .header {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .button-group {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Time Series SVD Analysis Experimental</h1>
            <p>Singular Value Decomposition for Time Series Mode Extraction by Claudio Iturra</p>
        </div>
        
        <div class="content">
            <div class="input-section">
                <div class="input-group">
                    <label for="timeSeriesData">Time Series Data (one value per line):</label>
                    <textarea id="timeSeriesData" placeholder="Enter your time series data here, one value per line...&#10;Example:&#10;1.2&#10;1.5&#10;2.1&#10;1.8&#10;..."></textarea>
                </div>
                
                <div class="input-group">
                    <label for="temporalResolution">Temporal Resolution (hours):</label>
                    <input type="number" id="temporalResolution" value="1" min="0.01" step="0.01" placeholder="e.g., 1 for hourly, 0.5 for 30 minutes">
                </div>
                
                <div class="input-group">
                    <label for="windowSize">Embedding Window Size:</label>
                    <input type="number" id="windowSize" value="50" min="2" placeholder="Number of time steps for embedding (default: 50)">
                </div>
                
                <div class="button-group">
                    <button onclick="performSVD()">Analyze Time Series</button>
                    <button onclick="clearResults()">Clear Results</button>
                    <button onclick="loadExample()">Load Example Data</button>
                </div>
            </div>
            
            <div class="equation-box">
                <div class="equation-title">SVD Mathematical Framework</div>
                <div class="equation">
                    <strong>Hankel Matrix Construction:</strong><br>
                    H = [x(t), x(t+1), ..., x(t+m-1)]<br>
                    where m is the embedding window size
                </div>
                <div class="equation">
                    <strong>Singular Value Decomposition:</strong><br>
                    H = U Î£ V<sup>T</sup>
                </div>
                <div class="equation">
                    <strong>Mode Extraction:</strong><br>
                    Mode k: x<sub>k</sub>(t) = Ïƒ<sub>k</sub> Â· u<sub>k</sub>(t) Â· v<sub>k</sub>(t)<br>
                    where Ïƒ<sub>k</sub> is the k-th singular value
                </div>
                <div class="equation">
                    <strong>Frequency Analysis:</strong><br>
                    Frequency (cycles/day) = f<sub>Hz</sub> Ã— 24 / Î”t<sub>hours</sub>
                </div>
            </div>
            
            <div id="results" class="results-section"></div>
        </div>
    </div>

    <script>
        let svdResults = null;
        
        function loadExample() {
            // Generate example time series with multiple frequencies
            const N = 200;
            const dt = 1; // 1 hour
            let data = [];
            
            for (let i = 0; i < N; i++) {
                const t = i * dt;
                // Combine multiple frequencies: daily, semi-daily, and trend
                const value = 2 * Math.sin(2 * Math.PI * t / 24) + // Daily cycle
                             1 * Math.sin(2 * Math.PI * t / 12) + // Semi-daily cycle
                             0.5 * Math.sin(2 * Math.PI * t / 8) + // 8-hour cycle
                             0.1 * t + // Linear trend
                             0.3 * Math.random(); // Noise
                data.push(value.toFixed(3));
            }
            
            document.getElementById('timeSeriesData').value = data.join('\n');
            document.getElementById('temporalResolution').value = '1';
            document.getElementById('windowSize').value = '50';
        }
        
        function clearResults() {
            document.getElementById('results').innerHTML = '';
            svdResults = null;
        }
        
        function performSVD() {
            const dataText = document.getElementById('timeSeriesData').value.trim();
            const temporalRes = parseFloat(document.getElementById('temporalResolution').value);
            const windowSize = parseInt(document.getElementById('windowSize').value);
            
            if (!dataText) {
                showError('Please enter time series data.');
                return;
            }
            
            if (!temporalRes || temporalRes <= 0) {
                showError('Please enter a valid temporal resolution.');
                return;
            }
            
            if (!windowSize || windowSize < 2) {
                showError('Please enter a valid window size (â‰¥ 2).');
                return;
            }
            
            try {
                showLoading();
                
                // Parse data
                const data = dataText.split('\n')
                    .map(line => line.trim())
                    .filter(line => line !== '')
                    .map(line => parseFloat(line));
                
                if (data.some(isNaN)) {
                    throw new Error('Invalid data format. Please ensure all values are numbers.');
                }
                
                if (data.length < windowSize) {
                    throw new Error(`Time series length (${data.length}) must be greater than window size (${windowSize}).`);
                }
                
                // Perform SVD analysis
                const results = analyzeSVD(data, temporalRes, windowSize);
                svdResults = results;
                
                // Display results
                displayResults(results, temporalRes);
                
            } catch (error) {
                showError(error.message);
            }
        }
        
        function analyzeSVD(data, temporalRes, windowSize) {
            const N = data.length;
            const M = N - windowSize + 1;
            
            // Create Hankel matrix
            const hankelMatrix = [];
            for (let i = 0; i < M; i++) {
                const row = [];
                for (let j = 0; j < windowSize; j++) {
                    row.push(data[i + j]);
                }
                hankelMatrix.push(row);
            }
            
            // Perform SVD using math.js
            const H = math.matrix(hankelMatrix);
            const svd = math.lup(math.multiply(math.transpose(H), H));
            
            // Alternative SVD implementation for better results
            const svdResult = performCustomSVD(hankelMatrix);
            
            return {
                originalData: data,
                hankelMatrix: hankelMatrix,
                svd: svdResult,
                windowSize: windowSize,
                temporalRes: temporalRes
            };
        }
        
        function performCustomSVD(matrix) {
            const m = matrix.length;
            const n = matrix[0].length;
            
            // Center the data
            const means = [];
            for (let j = 0; j < n; j++) {
                let sum = 0;
                for (let i = 0; i < m; i++) {
                    sum += matrix[i][j];
                }
                means[j] = sum / m;
            }
            
            const centeredMatrix = [];
            for (let i = 0; i < m; i++) {
                centeredMatrix[i] = [];
                for (let j = 0; j < n; j++) {
                    centeredMatrix[i][j] = matrix[i][j] - means[j];
                }
            }
            
            // Compute covariance matrix C = X^T * X
            const cov = [];
            for (let i = 0; i < n; i++) {
                cov[i] = [];
                for (let j = 0; j < n; j++) {
                    let sum = 0;
                    for (let k = 0; k < m; k++) {
                        sum += centeredMatrix[k][i] * centeredMatrix[k][j];
                    }
                    cov[i][j] = sum;
                }
            }
            
            // Power iteration to find eigenvalues and eigenvectors
            const numModes = Math.min(8, n);
            const eigenvalues = [];
            const eigenvectors = [];
            
            for (let mode = 0; mode < numModes; mode++) {
                // Initialize random vector
                let v = [];
                for (let i = 0; i < n; i++) {
                    v[i] = Math.random() - 0.5;
                }
                
                // Power iteration
                for (let iter = 0; iter < 100; iter++) {
                    // Multiply by covariance matrix
                    const newV = [];
                    for (let i = 0; i < n; i++) {
                        let sum = 0;
                        for (let j = 0; j < n; j++) {
                            sum += cov[i][j] * v[j];
                        }
                        newV[i] = sum;
                    }
                    
                    // Orthogonalize against previous eigenvectors
                    for (let prev = 0; prev < eigenvectors.length; prev++) {
                        let dot = 0;
                        for (let i = 0; i < n; i++) {
                            dot += newV[i] * eigenvectors[prev][i];
                        }
                        for (let i = 0; i < n; i++) {
                            newV[i] -= dot * eigenvectors[prev][i];
                        }
                    }
                    
                    // Normalize
                    let norm = 0;
                    for (let i = 0; i < n; i++) {
                        norm += newV[i] * newV[i];
                    }
                    norm = Math.sqrt(norm);
                    
                    if (norm < 1e-10) break;
                    
                    for (let i = 0; i < n; i++) {
                        newV[i] /= norm;
                    }
                    
                    v = newV;
                }
                
                // Compute eigenvalue
                let eigenvalue = 0;
                for (let i = 0; i < n; i++) {
                    let sum = 0;
                    for (let j = 0; j < n; j++) {
                        sum += cov[i][j] * v[j];
                    }
                    eigenvalue += v[i] * sum;
                }
                
                if (eigenvalue > 1e-10) {
                    eigenvalues.push(eigenvalue);
                    eigenvectors.push([...v]);
                }
            }
            
            // Sort by eigenvalue (descending)
            const indices = eigenvalues.map((_, i) => i);
            indices.sort((a, b) => eigenvalues[b] - eigenvalues[a]);
            
            const sortedEigenvalues = indices.map(i => eigenvalues[i]);
            const sortedEigenvectors = indices.map(i => eigenvectors[i]);
            
            // Compute modes using proper SVD reconstruction
            const modes = [];
            const singularValues = [];
            const originalLength = matrix.length + n - 1; // Original time series length
            
            for (let mode = 0; mode < sortedEigenvalues.length; mode++) {
                const eigenvalue = sortedEigenvalues[mode];
                const eigenvector = sortedEigenvectors[mode];
                
                // Project data onto eigenvector to get temporal coefficients
                const temporalCoeffs = [];
                for (let i = 0; i < m; i++) {
                    let projection = 0;
                    for (let j = 0; j < n; j++) {
                        projection += centeredMatrix[i][j] * eigenvector[j];
                    }
                    temporalCoeffs.push(projection);
                }
                
                // Reconstruct mode time series using diagonal averaging (Hankel to Toeplitz)
                const modeTimeSeries = new Array(originalLength).fill(0);
                const counts = new Array(originalLength).fill(0);
                
                for (let i = 0; i < m; i++) {
                    for (let j = 0; j < n; j++) {
                        const timeIndex = i + j;
                        if (timeIndex < originalLength) {
                            // Reconstruct using outer product of temporal and spatial components
                            const reconstructedValue = temporalCoeffs[i] * eigenvector[j];
                            modeTimeSeries[timeIndex] += reconstructedValue;
                            counts[timeIndex]++;
                        }
                    }
                }
                
                // Average over all contributions to each time point
                for (let t = 0; t < originalLength; t++) {
                    if (counts[t] > 0) {
                        modeTimeSeries[t] /= counts[t];
                    }
                }
                
                // Scale by singular value
                const singularValue = Math.sqrt(eigenvalue);
                for (let t = 0; t < originalLength; t++) {
                    modeTimeSeries[t] *= singularValue;
                }
                
                modes.push(modeTimeSeries);
                singularValues.push(singularValue);
            }
            
            return {
                singularValues: singularValues,
                modes: modes,
                totalVariance: sortedEigenvalues.reduce((a, b) => a + b, 0),
                eigenvectors: sortedEigenvectors,
                eigenvalues: sortedEigenvalues
            };
        }
        
        function displayResults(results, temporalRes) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';
            
            const { originalData, svd, windowSize } = results;
            const { singularValues, modes } = svd;
            
            // Display singular values
            const svInfo = document.createElement('div');
            svInfo.className = 'mode-info';
            const totalVariance = svd.totalVariance;
            const cumulativeVariance = [];
            let cumSum = 0;
            
            for (let i = 0; i < singularValues.length; i++) {
                const eigenvalue = singularValues[i] * singularValues[i];
                cumSum += eigenvalue;
                cumulativeVariance.push((cumSum * 100 / totalVariance).toFixed(1));
            }
            
            svInfo.innerHTML = `
                <h3>SVD Analysis Results</h3>
                <p><strong>Original time series length:</strong> ${originalData.length} points</p>
                <p><strong>Embedding window size:</strong> ${windowSize}</p>
                <p><strong>Number of modes extracted:</strong> ${modes.length}</p>
                <p><strong>Temporal resolution:</strong> ${temporalRes} hours</p>
                <p><strong>Total variance:</strong> ${totalVariance.toFixed(4)}</p>
                <p><strong>First 3 modes explain:</strong> ${cumulativeVariance[2] || 'N/A'}% of total variance</p>
            `;
            resultsDiv.appendChild(svInfo);
            
            // Plot original time series
            plotTimeSeries(originalData, temporalRes, 'Original Time Series', 'originalPlot');
            
            // Plot modes and their spectra
            for (let i = 0; i < Math.min(5, modes.length); i++) {
                plotMode(modes[i], singularValues[i], i + 1, temporalRes);
            }
        }
        
        function plotTimeSeries(data, temporalRes, title, divId) {
            const resultsDiv = document.getElementById('results');
            
            const plotDiv = document.createElement('div');
            plotDiv.id = divId || `plot_${Date.now()}`;
            plotDiv.className = 'plot-container';
            resultsDiv.appendChild(plotDiv);
            
            const timeAxis = data.map((_, i) => i * temporalRes);
            
            const trace = {
                x: timeAxis,
                y: data,
                type: 'scatter',
                mode: 'lines',
                name: title,
                line: { color: '#2c3e50', width: 2 }
            };
            
            const layout = {
                title: {
                    text: title,
                    font: { size: 16, color: '#2c3e50' }
                },
                xaxis: { 
                    title: 'Time (hours)',
                    gridcolor: '#f0f0f0'
                },
                yaxis: { 
                    title: 'Amplitude',
                    gridcolor: '#f0f0f0'
                },
                plot_bgcolor: 'white',
                paper_bgcolor: 'white',
                margin: { t: 50, r: 50, b: 50, l: 50 }
            };
            
            Plotly.newPlot(plotDiv.id, [trace], layout, {responsive: true});
        }
        
        function plotMode(modeData, singularValue, modeNumber, temporalRes) {
            const resultsDiv = document.getElementById('results');
            
            // Mode info
            const modeInfo = document.createElement('div');
            modeInfo.className = 'mode-info';
            const totalVariance = svdResults?.svd.totalVariance || 1;
            const eigenvalue = singularValue * singularValue;
            const variancePercent = (eigenvalue * 100 / totalVariance).toFixed(2);
            
            modeInfo.innerHTML = `
                <h3>Mode ${modeNumber}</h3>
                <p><strong>Singular Value:</strong> ${singularValue.toFixed(4)}</p>
                <p><strong>Eigenvalue:</strong> ${eigenvalue.toFixed(4)}</p>
                <p><strong>Variance Explained:</strong> ${variancePercent}%</p>
            `;
            resultsDiv.appendChild(modeInfo);
            
            // Time series plot
            const timeDiv = document.createElement('div');
            timeDiv.id = `mode_time_${modeNumber}`;
            timeDiv.className = 'plot-container';
            resultsDiv.appendChild(timeDiv);
            
            const timeAxis = modeData.map((_, i) => i * temporalRes);
            
            const timeTrace = {
                x: timeAxis,
                y: modeData,
                type: 'scatter',
                mode: 'lines',
                name: `Mode ${modeNumber}`,
                line: { color: `hsl(${(modeNumber - 1) * 60}, 70%, 50%)`, width: 2 }
            };
            
            const timeLayout = {
                title: {
                    text: `Mode ${modeNumber} - Time Series`,
                    font: { size: 16, color: '#2c3e50' }
                },
                xaxis: { 
                    title: 'Time (hours)',
                    gridcolor: '#f0f0f0'
                },
                yaxis: { 
                    title: 'Amplitude',
                    gridcolor: '#f0f0f0'
                },
                plot_bgcolor: 'white',
                paper_bgcolor: 'white'
            };
            
            Plotly.newPlot(timeDiv.id, [timeTrace], timeLayout, {responsive: true});
            
            // Frequency spectrum
            const spectrumDiv = document.createElement('div');
            spectrumDiv.id = `mode_spectrum_${modeNumber}`;
            spectrumDiv.className = 'plot-container';
            resultsDiv.appendChild(spectrumDiv);
            
            const spectrum = computeSpectrum(modeData, temporalRes);
            
            const spectrumTrace = {
                x: spectrum.frequencies,
                y: spectrum.power,
                type: 'scatter',
                mode: 'lines',
                name: `Mode ${modeNumber} Spectrum`,
                line: { color: `hsl(${(modeNumber - 1) * 60}, 70%, 50%)`, width: 2 }
            };
            
            const spectrumLayout = {
                title: {
                    text: `Mode ${modeNumber} - Power Spectrum`,
                    font: { size: 16, color: '#2c3e50' }
                },
                xaxis: { 
                    title: 'Frequency (cycles/day)',
                    gridcolor: '#f0f0f0'
                },
                yaxis: { 
                    title: 'Power',
                    gridcolor: '#f0f0f0'
                },
                plot_bgcolor: 'white',
                paper_bgcolor: 'white'
            };
            
            Plotly.newPlot(spectrumDiv.id, [spectrumTrace], spectrumLayout, {responsive: true});
        }
        
        function computeSpectrum(data, temporalRes) {
            const N = data.length;
            const dt = temporalRes / 24; // Convert to days
            
            // Simple FFT approximation
            const frequencies = [];
            const power = [];
            
            for (let k = 0; k < Math.floor(N/2); k++) {
                const freq = k / (N * dt); // cycles per day
                
                let real = 0, imag = 0;
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    real += data[n] * Math.cos(angle);
                    imag += data[n] * Math.sin(angle);
                }
                
                const magnitude = Math.sqrt(real * real + imag * imag) / N;
                
                if (freq <= 10) { // Limit to reasonable frequencies
                    frequencies.push(freq);
                    power.push(magnitude);
                }
            }
            
            return { frequencies, power };
        }
        
        function showError(message) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `<div class="error"><strong>Error:</strong> ${message}</div>`;
        }
        
        function showLoading() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<div class="loading">ðŸ”„ Performing SVD analysis...</div>';
        }
        
        // Load example data on page load
        window.onload = function() {
            loadExample();
        };
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'96d99ab551d28937',t:'MTc1NDkzNDkzMS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>

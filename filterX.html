<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Time‑Series Filters (Low/High/Band‑pass)</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fft.js@4.0.4/dist/fft.min.js"></script>
  <style>
    :root{
      --bg: #0b1020; --panel:#12182b; --muted:#9aa4b2; --text:#e8edf2; --accent:#7dd3fc; --accent2:#a78bfa;
    }
    *{box-sizing:border-box}
    body{margin:0; font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:radial-gradient(1200px 600px at 70% -10%, #1a2350, transparent), var(--bg); color:var(--text)}
    header{padding:20px 20px 0; text-align:center}
    h1{margin:0; font-size:clamp(22px,3vw,32px)}
    .sub{color:var(--muted); margin-top:6px}
    .wrap{max-width:1200px; margin:22px auto; padding:0 16px;}
    .grid{display:grid; grid-template-columns: 1fr 1fr; gap:16px}
    .panel{background:linear-gradient(180deg,#12182b,#0f1530); border:1px solid #273055; border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .panel h2{font-size:16px; font-weight:700; letter-spacing:.4px; margin:0; padding:14px 16px; border-bottom:1px solid #223056; color:#cfe3ff}
    .panel .content{padding:14px 16px}
    textarea{width:100%; min-height:220px; resize:vertical; color:var(--text); background:#0e1431; border:1px solid #263057; border-radius:12px; padding:12px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
    .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin:8px 0}
    .row label{font-size:13px; color:#d7e4ff}
    input[type="number"], select{background:#0e1431; color:var(--text); border:1px solid #263057; border-radius:10px; padding:8px 10px; min-width:110px}
    .hint{font-size:12px; color:var(--muted)}
    .controls{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
    button{border:1px solid #2a355f; background:linear-gradient(180deg, #1a2550, #142046); color:#e7f5ff; padding:10px 14px; border-radius:12px; font-weight:600; cursor:pointer}
    button.primary{background:linear-gradient(180deg, #1e60a8, #144b84); border-color:#2872c7}
    button:disabled{opacity:.5; cursor:not-allowed}
    .stack{display:flex; flex-direction:column; gap:8px}
    .pill{display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px; background:#0f1637; border:1px solid #2b3a6b; font-size:12px}
    canvas{width:100% !important; height:420px !important}
    .footer{color:var(--muted); text-align:center; font-size:12px; padding:16px}
    .grid-3{display:grid; grid-template-columns: repeat(3, 1fr); gap:10px}
    .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#0b1333; border:1px solid #2a3560; padding:2px 6px; border-radius:6px}
  </style>
</head>
<body>
  <header>
    <h1>Time‑Series Filtering: Low‑pass • High‑pass • Band‑pass</h1>
    <div class="sub">Paste your series, set sampling resolution (hours), choose a filter in HOURS (e.g., band‑pass 10–24 h), and download the result by Claudio I.</div>
  </header>

  <div class="wrap">
    <div class="grid">
      <section class="panel">
        <h2>1) Paste time series</h2>
        <div class="content stack">
          <textarea id="inputSeries" placeholder="One value per line (evenly sampled), or two columns (timestamp, value). Example:\n\n0.45\n0.41\n0.38\n...\n\n—or—\n2025-01-01T00:00, 0.45\n2025-01-01T01:00, 0.41\n2025-01-01T02:00, 0.38"></textarea>
          <div class="row">
            <label>Sampling resolution (Δt, hours):</label>
            <input type="number" id="dtHours" step="0.0001" min="0.000001" value="1" />
            <span class="hint">This is the time between successive samples.</span>
          </div>
          <div class="row">
            <span class="pill">N = <span id="nCount">0</span> samples</span>
            <span class="pill">Mean = <span id="meanVal">–</span></span>
            <span class="pill">Std = <span id="stdVal">–</span></span>
          </div>
        </div>
      </section>

      <section class="panel">
        <h2>2) Filter settings (cutoffs in HOURS)</h2>
        <div class="content stack">
          <div class="row">
            <label><input type="radio" name="ftype" value="low" checked> Low‑pass</label>
            <label><input type="radio" name="ftype" value="high"> High‑pass</label>
            <label><input type="radio" name="ftype" value="band"> Band‑pass</label>
          </div>
          <div id="lowHighControls" class="row">
            <label>Cutoff period (hours):</label>
            <input type="number" id="cutoffHours" step="0.1" min="0.0001" value="40"/>
            <span class="hint">Low‑pass keeps periods ≥ cutoff (frequencies ≤ 1/cutoff). High‑pass keeps periods ≤ cutoff.</span>
          </div>
          <div id="bandControls" class="row" style="display:none">
            <label>Band (hours):</label>
            <input type="number" id="bandMin" step="0.1" min="0.0001" value="10"/>
            <span>to</span>
            <input type="number" id="bandMax" step="0.1" min="0.0001" value="24"/>
            <span class="hint">Keeps periods between min and max (e.g., 10–24 h).</span>
          </div>
          <div class="controls">
            <button class="primary" id="runBtn">Apply filter</button>
            <button id="downloadBtn" disabled>Download filtered CSV</button>
            <button id="clearBtn">Clear</button>
          </div>
        </div>
      </section>
    </div>

    <section class="panel" style="margin-top:16px">
      <h2>3) Plot</h2>
      <div class="content">
        <div class="row hint">Original and filtered series are plotted below. X‑axis is sample index (0…N‑1). If you provided timestamps, they are exported but not shown on the chart.</div>
        <canvas id="chart"></canvas>
      </div>
    </section>

    <div class="footer">Tip: For best results, your series should be evenly sampled. The filters are applied in the frequency domain with zero‑phase (FFT ideal masks).</div>
  </div>

<script>
  // ---------- Helpers ----------
  const byId = (id) => document.getElementById(id);
  const fmt = (x) => (Number.isFinite(x)? x.toFixed(4) : '–');

  function parseSeries(text){
    const lines = text.split(/\r?\n/).map(s => s.trim()).filter(s => s.length);
    const values = [];
    const timestamps = [];
    for(const line of lines){
      // Accept CSV, TSV, or whitespace; either single value or timestamp,value
      const parts = line.split(/[\s,;\t]+/).filter(Boolean);
      if(parts.length === 1){
        const v = Number(parts[0]);
        if(Number.isFinite(v)) values.push(v);
      } else {
        const v = Number(parts[parts.length-1]);
        if(Number.isFinite(v)){
          values.push(v);
          timestamps.push(parts.slice(0, parts.length-1).join(' '));
        }
      }
    }
    return {values, timestamps};
  }

  function basicStats(arr){
    if(!arr.length) return {mean: NaN, std: NaN};
    const m = arr.reduce((a,b)=>a+b,0)/arr.length;
    const v = arr.reduce((a,b)=>a+(b-m)*(b-m),0)/arr.length;
    return {mean:m, std: Math.sqrt(v)};
  }

  function nextPow2(n){
    return Math.pow(2, Math.ceil(Math.log2(Math.max(1,n))));
  }

  function applyFFTFilter(values, dtHours, type, params){
    const N = values.length;
    if(N===0) return [];

    // Zero‑mean to reduce DC leakage (we add mean back after)
    const mean = values.reduce((a,b)=>a+b,0)/N;
    const x = Float64Array.from(values.map(v=>v-mean));

    // Zero‑pad to power of two for speed
    const M = nextPow2(N);
    const re = new Float64Array(M);
    const im = new Float64Array(M);
    for(let i=0;i<N;i++) re[i]=x[i];

    const ffter = new FFT(M);
    ffter.transform(re, im, re, im); // FFT(re+ i*0) -> (re,im)

    // Frequency (cycles per hour)
    const df = 1/(M*dtHours);

    // Build mask (symmetrical for negative freqs)
    const maskRe = new Float64Array(M).fill(0);
    const maskIm = new Float64Array(M).fill(0);

    const pass = (fAbs)=>{
      if(type==='low'){
        const fcut = 1/params.cutoffHours; // <= fcut passes
        return fAbs <= fcut;
      } else if(type==='high'){
        const fcut = 1/params.cutoffHours; // >= fcut passes
        return fAbs >= fcut;
      } else { // band
        const f1 = 1/Math.max(params.maxHours, params.minHours); // lower freq bound
        const f2 = 1/Math.min(params.maxHours, params.minHours); // upper freq bound
        // band: f in [f1, f2]
        return fAbs >= f1 && fAbs <= f2;
      }
    };

    for(let k=0;k<M;k++){
      const kShift = k<=M/2? k : M-k; // mirror for negative freqs
      const fAbs = kShift*df;
      const on = pass(fAbs) ? 1 : 0;
      maskRe[k] = on; // multiply complex spectrum by real mask
    }

    // Apply mask in frequency domain
    for(let k=0;k<M;k++){
      re[k] *= maskRe[k];
      im[k] *= maskRe[k];
    }

    // Inverse FFT
    ffter.inverseTransform(re, im, re, im);
    // Normalize (fft.js uses unnormalized forward, normalized inverse)

    // Extract first N samples and add mean back (zero‑phase result)
    const y = new Array(N);
    for(let i=0;i<N;i++) y[i] = re[i] + mean;
    return y;
  }

  // ---------- UI Logic ----------
  const input = byId('inputSeries');
  const dt = byId('dtHours');
  const nCount = byId('nCount');
  const meanVal = byId('meanVal');
  const stdVal = byId('stdVal');
  const runBtn = byId('runBtn');
  const dlBtn = byId('downloadBtn');
  const clearBtn = byId('clearBtn');

  const cutoffHours = byId('cutoffHours');
  const bandMin = byId('bandMin');
  const bandMax = byId('bandMax');
  const lowHighControls = byId('lowHighControls');
  const bandControls = byId('bandControls');

  let parsed = {values:[], timestamps:[]};
  let filtered = [];
  let chart;

  function refreshStats(){
    parsed = parseSeries(input.value);
    const {mean, std} = basicStats(parsed.values);
    nCount.textContent = parsed.values.length;
    meanVal.textContent = fmt(mean);
    stdVal.textContent = fmt(std);
  }

  input.addEventListener('input', refreshStats);
  window.addEventListener('DOMContentLoaded', refreshStats);

  // Toggle filter control groups
  document.querySelectorAll('input[name="ftype"]').forEach(r=>{
    r.addEventListener('change', ()=>{
      const t = document.querySelector('input[name="ftype"]:checked').value;
      lowHighControls.style.display = (t==='band') ? 'none' : 'flex';
      bandControls.style.display = (t==='band') ? 'flex' : 'none';
    });
  });

  function ensureValid(){
    const t = document.querySelector('input[name="ftype"]:checked').value;
    const N = parsed.values.length;
    const dtH = Number(dt.value);
    if(!N || !Number.isFinite(dtH) || dtH<=0) return {ok:false, msg:'Please paste data and set a valid Δt (hours).'};
    if(t==='band'){
      const a = Number(bandMin.value), b = Number(bandMax.value);
      if(!(a>0 && b>0)) return {ok:false, msg:'Band limits must be positive hours.'};
      if(Math.min(a,b) <= dtH/2) return {ok:true}; // allow but warn silently (Nyquist handled by mask)
      return {ok:true};
    } else {
      const c = Number(cutoffHours.value);
      if(!(c>0)) return {ok:false, msg:'Cutoff period must be > 0 hours.'};
      return {ok:true};
    }
  }

  function buildCSV(values, timestamps){
    let out = 'index';
    if(timestamps.length) out += ',timestamp';
    out += ',value\n';
    for(let i=0;i<values.length;i++){
      out += i;
      if(timestamps.length) out += ','+JSON.stringify(timestamps[i]||'');
      out += ','+values[i]+"\n";
    }
    return out;
  }

  function download(filename, text){
    const blob = new Blob([text], {type:'text/csv;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 5000);
  }

  function plot(original, filtered){
    const labels = Array.from({length: original.length}, (_,i)=> i);
    const ctx = document.getElementById('chart');
    const data = {
      labels,
      datasets: [
        {label:'Original', data: original, borderWidth:2, tension:0.1},
        {label:'Filtered', data: filtered, borderWidth:2, tension:0.1}
      ]
    };
    const options = {
      responsive:true,
      interaction: {mode:'index', intersect:false},
      scales: {
        x: {title:{display:true, text:'Sample index'}},
        y: {title:{display:true, text:'Value'}}
      },
      plugins: {
        legend: {labels:{usePointStyle:true, boxWidth:8}},
        tooltip: {callbacks: { label: (ctx)=> `${ctx.dataset.label}: ${fmt(ctx.parsed.y)}` }}
      }
    };
    if(chart){ chart.destroy(); }
    chart = new Chart(ctx, {type:'line', data, options});
  }

  runBtn.addEventListener('click', ()=>{
    refreshStats();
    const chk = ensureValid();
    if(!chk.ok){ alert(chk.msg); return; }

    const dtH = Number(dt.value);
    const ftype = document.querySelector('input[name="ftype"]:checked').value;
    let params = {};
    if(ftype==='band'){
      params = { minHours: Number(bandMin.value), maxHours: Number(bandMax.value) };
    } else {
      params = { cutoffHours: Number(cutoffHours.value) };
    }

    try{
      filtered = applyFFTFilter(parsed.values, dtH, ftype, params);
      plot(parsed.values, filtered);
      dlBtn.disabled = false;
    } catch(err){
      console.error(err);
      alert('Error while filtering: '+ err.message);
    }
  });

  dlBtn.addEventListener('click', ()=>{
    if(!filtered.length){ alert('No filtered data yet.'); return; }
    const csv = buildCSV(filtered, parsed.timestamps);
    const t = document.querySelector('input[name="ftype"]:checked').value;
    const name = t==='band'
      ? `filtered_band_${bandMin.value}to${bandMax.value}h.csv`
      : `filtered_${t}_${cutoffHours.value}h.csv`;
    download(name, csv);
  });

  clearBtn.addEventListener('click', ()=>{
    input.value = '';
    filtered = [];
    dlBtn.disabled = true;
    refreshStats();
    if(chart){ chart.destroy(); chart = null; }
  });
</script>
</body>
</html>
